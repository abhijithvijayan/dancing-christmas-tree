<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizer Command Center</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #111;
            color: #fff;
            padding: 20px;
            text-align: center;
        }
        canvas {
            background: #000;
            border: 2px solid #333;
            margin-top: 10px;
            width: 90%;
            height: 500px;
            border-radius: 4px;
            cursor: crosshair;
        }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; }
        button { padding: 12px 24px; font-size: 16px; cursor: pointer; background: #333; color: white; border: 1px solid #555; border-radius: 5px; transition: all 0.2s; }
        button:hover { background: #444; }

        button#connectBtn { background: #007bff; border-color: #007bff; }
        button#connectBtn:hover { background: #0056b3; }

        button#resetBtn { background: #d39e00; border-color: #c69500; color: #000; }
        button#resetBtn:hover { background: #e0a800; }

        button#disconnectBtn { background: #dc3545; border-color: #dc3545; display: none; }
        button#disconnectBtn:hover { background: #bd2130; }

        .legend { display: flex; justify-content: center; gap: 20px; margin-bottom: 10px; font-size: 13px; flex-wrap: wrap; }
        .dot { width: 10px; height: 10px; display: inline-block; border-radius: 50%; margin-right: 5px; }
        #tooltip { position: absolute; background: rgba(20, 20, 20, 0.95); border: 1px solid #777; padding: 10px; border-radius: 4px; font-size: 12px; pointer-events: none; display: none; text-align: left; z-index: 1000; min-width: 160px; }
    </style>
</head>
<body>

<h2>üéµ Visualizer Command Center</h2>

<div class="legend">
    <span><span class="dot" style="background:#0f0;"></span>Raw Input</span>
    <span><span class="dot" style="background:#FFA500;"></span>LED Bar</span>
    <span><span class="dot" style="background:#f0f;"></span>Amplitude</span>
    <span><span class="dot" style="background:#fff;"></span>Peak Dot</span>
    <span><span class="dot" style="background:#0ff;"></span>Dyn Max</span>
</div>

<div class="controls">
    <button id="connectBtn">üîå CONNECT</button>
    <button id="pauseBtn">‚è∏ PAUSE</button>
    <button id="resetBtn">üóëÔ∏è CLEAR CHART</button>
    <button id="disconnectBtn">‚ùå DISCONNECT</button>
</div>

<div id="status">Status: Disconnected</div>
<div id="tooltip"></div>
<canvas id="chart"></canvas>

<script>
    const connectBtn = document.getElementById('connectBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const statusDisplay = document.getElementById('status');
    const canvas = document.getElementById('chart');
    const tooltip = document.getElementById('tooltip');
    const ctx = canvas.getContext('2d');

    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    // --- DATA ARRAYS ---
    let rawData = new Array(Math.floor(rect.width)).fill(512);
    let ampData = new Array(Math.floor(rect.width)).fill(0);
    let ledData = new Array(Math.floor(rect.width)).fill(0);
    let peakData = new Array(Math.floor(rect.width)).fill(0);
    let maxData = new Array(Math.floor(rect.width)).fill(100);
    let biasData = new Array(Math.floor(rect.width)).fill(512);

    let port, reader, readableStreamClosed;
    let isPaused = false;
    let inputBuffer = '';
    let mouseX = -1; let isHovering = false;

    // Current "Live" Values
    let currentBias = 512;
    let currentMax = 100;
    const NUM_LEDS = 300;

    // STATS
    let currentLedLit = 0;
    let maxLedLit = 0;
    let minLedLit = NUM_LEDS;

    function draw() {
        ctx.clearRect(0, 0, rect.width, rect.height);

        let topCenter = rect.height * 0.30;
        let bottomBase = rect.height * 0.85;
        let scaleHeight = rect.height * 0.40;

        // --- GRID & REFS ---
        // Use current live bias for the grid line
        let zeroOffset = (currentBias - 512) / 512;
        let zeroY = topCenter - (zeroOffset * scaleHeight);
        ctx.strokeStyle = '#666'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(0, zeroY); ctx.lineTo(rect.width, zeroY); ctx.stroke(); ctx.setLineDash([]);

        // Use current live max for the grid line
        let maxY = bottomBase - ((currentMax / 1023) * scaleHeight);
        ctx.strokeStyle = '#0ff'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
        ctx.beginPath(); ctx.moveTo(0, maxY); ctx.lineTo(rect.width, maxY); ctx.stroke(); ctx.setLineDash([]);

        ctx.strokeStyle = '#444'; ctx.beginPath(); ctx.moveTo(0, bottomBase); ctx.lineTo(rect.width, bottomBase); ctx.stroke();

        // --- RAW SIGNAL (Green) ---
        ctx.beginPath(); ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1;
        for (let i = 0; i < rawData.length; i++) {
            let normalized = (rawData[i] - 512) / 512;
            let y = topCenter - (normalized * scaleHeight);
            if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
        ctx.stroke();

        // --- LED BAR (Orange) ---
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255, 165, 0, 0.4)'; ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)'; ctx.lineWidth = 1;
        ctx.moveTo(0, bottomBase);
        for (let i = 0; i < ledData.length; i++) {
            let h = (ledData[i] / NUM_LEDS) * scaleHeight;
            let y = bottomBase - h;
            ctx.lineTo(i, y);
        }
        ctx.lineTo(rect.width, bottomBase); ctx.fill(); ctx.stroke();

        // --- AMPLITUDE (Pink) ---
        ctx.beginPath(); ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
        for (let i = 0; i < ampData.length; i++) {
            let h = (ampData[i] / 1023) * scaleHeight;
            let y = bottomBase - h;
            if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
        ctx.stroke();

        // --- PEAK DOT (White) ---
        ctx.beginPath(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        for (let i = 0; i < peakData.length; i++) {
            let h = (peakData[i] / NUM_LEDS) * scaleHeight;
            let y = bottomBase - h;
            if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
        ctx.stroke();

        // --- INFO BOXES ---
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(10, 10, 200, 24);
        ctx.fillStyle = '#bbb'; ctx.font = '12px Courier New'; ctx.textAlign = "left";
        ctx.fillText("Zero Point (Bias): " + currentBias, 20, 26);

        let rightMargin = 10;
        let boxWidth = 220;
        let startX = rect.width - boxWidth - rightMargin;
        let startY = 10;
        let lineHeight = 26;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(startX, startY, boxWidth, lineHeight * 4 + 5);

        ctx.fillStyle = '#0ff'; ctx.font = 'bold 12px Courier New'; ctx.textAlign = "left";
        ctx.fillText("Auto-Scaling Max: " + currentMax, startX + 10, startY + 16);

        ctx.fillStyle = '#ff0';
        ctx.fillText("Current LEDs Lit: " + currentLedLit, startX + 10, startY + 16 + lineHeight);

        ctx.fillStyle = '#FFA500';
        ctx.fillText("Max LEDs Lit:     " + maxLedLit, startX + 10, startY + 16 + lineHeight * 2);

        ctx.fillStyle = '#ccc';
        ctx.fillText("Min LEDs Lit:     " + minLedLit, startX + 10, startY + 16 + lineHeight * 3);


        // --- TOOLTIP ---
        if (isHovering && mouseX >= 0 && mouseX < rawData.length) {
            let index = Math.floor(mouseX);
            let rVal = rawData[index];
            let aVal = ampData[index];
            let lVal = ledData[index];
            let pVal = peakData[index];

            let histMax = maxData[index];
            let histBias = biasData[index];

            if(rVal !== undefined) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]); ctx.beginPath(); ctx.moveTo(mouseX, 0); ctx.lineTo(mouseX, rect.height); ctx.stroke(); ctx.setLineDash([]);
                tooltip.innerHTML = `
                        <div style="color:#888; border-bottom:1px solid #444; margin-bottom:4px;">
                            Bias: <b>${histBias}</b> | Max: <b style="color:#0ff">${histMax}</b>
                        </div>
                        <span style="color:#0f0">‚óè</span> Raw: <b style="color:#fff">${rVal}</b><br>
                        <span style="color:#f0f">‚óè</span> Sound: <b style="color:#fff">${aVal}</b><br>
                        <hr style="border-color:#333; margin:3px 0">
                        <span style="color:#FFA500">‚óè</span> LED Bar: <b>${lVal}</b><br>
                        <span style="color:#fff">‚óè</span> Peak: <b>${pVal}</b>
                    `;
            }
        }
        requestAnimationFrame(draw);
    }
    draw();

    function processData(text) {
        inputBuffer += text;
        let lines = inputBuffer.split('\n');
        inputBuffer = lines.pop();
        for (let line of lines) {
            let parts = line.trim().split(',');
            if (parts.length === 6) {
                let r = parseInt(parts[0]); let a = parseInt(parts[1]); let m = parseInt(parts[2]);
                let z = parseInt(parts[3]); let l = parseInt(parts[4]); let p = parseInt(parts[5]);
                if (!isNaN(r)) {
                    rawData.push(r); rawData.shift(); ampData.push(a); ampData.shift();
                    ledData.push(l); ledData.shift(); peakData.push(p); peakData.shift();

                    // Handle Globals
                    if (!isNaN(m)) currentMax = m;
                    if (!isNaN(z)) currentBias = z;

                    maxData.push(currentMax); maxData.shift();
                    biasData.push(currentBias); biasData.shift();

                    // Stats
                    currentLedLit = l;
                    if (l === 0) {
                        minLedLit = 0; maxLedLit = 0;
                    } else {
                        if (maxLedLit === 0) minLedLit = l;
                        if (l > maxLedLit) maxLedLit = l;
                        if (l < minLedLit) minLedLit = l;
                    }
                }
            }
        }
    }

    resetBtn.addEventListener('click', () => {
        rawData.fill(512); ampData.fill(0); ledData.fill(0); peakData.fill(0);
        maxData.fill(100); biasData.fill(512); // Reset history
        maxLedLit = 0; minLedLit = NUM_LEDS; currentLedLit = 0;
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; isHovering = true; tooltip.style.left = (e.pageX + 15) + 'px'; tooltip.style.top = (e.pageY + 15) + 'px'; tooltip.style.display = 'block';
    });
    canvas.addEventListener('mouseleave', () => { isHovering = false; tooltip.style.display = 'none'; });
    pauseBtn.addEventListener('click', () => { isPaused = !isPaused; pauseBtn.textContent = isPaused ? "‚ñ∂ RESUME" : "‚è∏ PAUSE"; pauseBtn.classList.toggle('active'); });

    connectBtn.addEventListener('click', async () => {
        if (!navigator.serial) return alert("Use Chrome/Edge");
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });

            statusDisplay.textContent = "Status: Connected!"; statusDisplay.style.color = "#0f0";
            connectBtn.style.display = 'none';
            disconnectBtn.style.display = 'inline-block';

            const textDecoder = new TextDecoderStream();
            readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();

            while (true) { const { value, done } = await reader.read(); if (done) break; if (!isPaused) processData(value); }
        } catch (err) { console.error(err); resetUI(); }
    });

    disconnectBtn.addEventListener('click', async () => {
        try {
            if (reader) { await reader.cancel(); reader = null; }
            if (readableStreamClosed) await readableStreamClosed.catch(() => {});
            if (port) { await port.close(); port = null; }
        } catch (e) { console.error("Disconnect Cleanup Error:", e); port = null; }
        resetUI();
    });

    function resetUI() {
        connectBtn.style.display = 'inline-block';
        disconnectBtn.style.display = 'none';
        statusDisplay.textContent = "Status: Disconnected"; statusDisplay.style.color = "#fff";
    }
</script>
</body>
</html>