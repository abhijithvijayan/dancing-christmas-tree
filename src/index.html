<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizer Command Center</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #111;
            color: #fff;
            padding: 20px;
            text-align: center;
        }
        canvas {
            background: #000;
            border: 2px solid #333;
            margin-top: 10px;
            width: 90%;
            height: 600px;
            border-radius: 4px;
            cursor: crosshair;
        }
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; }
        button { padding: 12px 24px; font-size: 16px; cursor: pointer; background: #333; color: white; border: 1px solid #555; border-radius: 5px; transition: all 0.2s; }
        button:hover { background: #444; }

        button#connectBtn { background: #007bff; border-color: #007bff; }
        button#connectBtn:hover { background: #0056b3; }

        button#resetBtn { background: #d39e00; border-color: #c69500; color: #000; }
        button#resetBtn:hover { background: #e0a800; }

        button#disconnectBtn { background: #dc3545; border-color: #dc3545; display: none; }
        button#disconnectBtn:hover { background: #bd2130; }

        .legend { display: flex; justify-content: center; gap: 20px; margin-bottom: 10px; font-size: 13px; flex-wrap: wrap; }
        .dot { width: 10px; height: 10px; display: inline-block; border-radius: 50%; margin-right: 5px; }
        #tooltip { position: absolute; background: rgba(20, 20, 20, 0.95); border: 1px solid #777; padding: 10px; border-radius: 4px; font-size: 12px; pointer-events: none; display: none; text-align: left; z-index: 1000; min-width: 160px; }
    </style>
</head>
<body>

<h2>üéµ Visualizer Command Center</h2>

<div class="legend">
    <span><span class="dot" style="background:#0f0;"></span>Raw Input</span>
    <span><span class="dot" style="background:#f0f;"></span>Amplitude</span>
    <span><span class="dot" style="background:#0ff;"></span>Dyn Max</span>
    <span><span class="dot" style="background:#FFA500;"></span>LED Bar</span>
    <span><span class="dot" style="background:#fff;"></span>Peak Dot</span>
</div>

<div class="controls">
    <button id="connectBtn">üîå CONNECT</button>
    <button id="pauseBtn">‚è∏ PAUSE</button>
    <button id="resetBtn">üóëÔ∏è CLEAR CHART</button>
    <button id="disconnectBtn">‚ùå DISCONNECT</button>
</div>

<div id="modeDisplay" style="margin: 10px; font-weight: bold; font-size: 18px; color: #888;">
    MODE: <span id="modeText">WAITING...</span>
</div>

<div id="status">Status: Disconnected</div>
<div id="tooltip"></div>
<canvas id="chart"></canvas>

<script>
    const connectBtn = document.getElementById('connectBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const statusDisplay = document.getElementById('status');
    const canvas = document.getElementById('chart');
    const tooltip = document.getElementById('tooltip');
    const ctx = canvas.getContext('2d');

    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);

    let rawData = new Array(Math.floor(rect.width)).fill(512);
    let ampData = new Array(Math.floor(rect.width)).fill(0);
    let ledData = new Array(Math.floor(rect.width)).fill(0);
    let peakData = new Array(Math.floor(rect.width)).fill(0);
    let maxData = new Array(Math.floor(rect.width)).fill(100);
    let biasData = new Array(Math.floor(rect.width)).fill(512);

    let port, reader, readableStreamClosed;
    let isPaused = false;
    let inputBuffer = '';
    let mouseX = -1; let isHovering = false;

    let currentBias = 512;
    let currentMax = 100;
    const NUM_LEDS = 300;

    let currentLedLit = 0;
    let maxLedLit = 0;
    let minLedLit = NUM_LEDS;

    function draw() {
        ctx.clearRect(0, 0, rect.width, rect.height);

        // Zone 1 (Raw): 15%
        // Zone 2 (Amp): 30%
        // Zone 3 (LED): 55%

        let h1 = rect.height * 0.15;
        let h2 = rect.height * 0.30;
        let h3 = rect.height * 0.55;

        // Define "Floors" (Y-coordinates where each zone ends)
        let floor1 = h1;
        let floor2 = h1 + h2;
        let floor3 = h1 + h2 + h3; // Effectively rect.height

        // Define "Drawing Scales" (Padding of 10% on top/bottom inside each zone)
        let scale1 = h1 * 0.8;
        let scale2 = h2 * 0.8;
        let scale3 = h3 * 0.9; // Give LED bar 90% space

        // Define "Base Lines" (Where 0 sits visually)
        let base1 = floor1 - (h1 * 0.1); // 10% padding from bottom of zone
        let base2 = floor2 - (h2 * 0.1);
        let base3 = floor3 - (h3 * 0.05); // 5% padding from bottom

        // --- DIVIDERS ---
        ctx.strokeStyle = '#333'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, floor1); ctx.lineTo(rect.width, floor1); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, floor2); ctx.lineTo(rect.width, floor2); ctx.stroke();


        // --- ZONE 1: RAW INPUT (Green) ---
        // Bias Grid Line
        let zeroOffset = (currentBias - 512) / 512;
        // Center of Zone 1 is (h1 / 2)
        let zeroY = (h1 / 2) - (zeroOffset * (scale1 / 2));

        ctx.strokeStyle = '#444'; ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(0, zeroY); ctx.lineTo(rect.width, zeroY); ctx.stroke(); ctx.setLineDash([]);

        ctx.beginPath(); ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1;
        for (let i = 0; i < rawData.length; i++) {
            let normalized = rawData[i] / 1023;
            let y = (floor1 - (h1 * 0.1)) - (normalized * scale1); // Base1 - mapped height
            if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
        ctx.stroke();

        // Label
        ctx.fillStyle = '#bbb'; ctx.font = '10px Courier New'; ctx.textAlign = "left";
        ctx.fillText("RAW ANALOG (" + currentBias + ")", 10, 15);


        // --- ZONE 2: AMPLITUDE (Pink) ---

        // Dyn Max Line
        ctx.beginPath(); ctx.strokeStyle = '#0ff'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]);
        for (let i = 0; i < maxData.length; i++) {
            let h = (maxData[i] / 1023) * scale2;
            let y = base2 - h;
            if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
        ctx.stroke(); ctx.setLineDash([]);

        // Amplitude
        ctx.beginPath(); ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 1;
        ctx.fillStyle = 'rgba(255, 0, 255, 0.1)';
        ctx.moveTo(0, base2);
        for (let i = 0; i < ampData.length; i++) {
            let h = (ampData[i] / 1023) * scale2;
            let y = base2 - h;
            ctx.lineTo(i, y);
        }
        ctx.lineTo(rect.width, base2); ctx.fill(); ctx.stroke();

        // Label
        ctx.fillStyle = '#bbb';
        ctx.fillText("MATH / PROCESSING", 10, floor1 + 15);
        ctx.fillStyle = '#0ff'; ctx.textAlign = "right";
        ctx.fillText("Dyn Max: " + currentMax, rect.width - 10, floor1 + 15);


        // --- ZONE 3: LED OUTPUT (Orange) ---
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255, 165, 0, 0.4)'; ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)'; ctx.lineWidth = 1;
        ctx.moveTo(0, base3);
        for (let i = 0; i < ledData.length; i++) {
            let h = (ledData[i] / NUM_LEDS) * scale3;
            let y = base3 - h;
            ctx.lineTo(i, y);
        }
        ctx.lineTo(rect.width, base3); ctx.fill(); ctx.stroke();

        // Peak Dot
        ctx.beginPath(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        for (let i = 0; i < peakData.length; i++) {
            let h = (peakData[i] / NUM_LEDS) * scale3;
            let y = base3 - h;
            if (i === 0) ctx.moveTo(i, y); else ctx.lineTo(i, y);
        }
        ctx.stroke();

        // Label
        ctx.fillStyle = '#bbb'; ctx.textAlign = "left";
        ctx.fillText("LED OUTPUT", 10, floor2 + 15);


        // --- STATS OVERLAY ---
        let boxWidth = 200;
        let startX = rect.width - boxWidth - 10;
        let startY = floor2 + 10;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(startX, startY, boxWidth, 80);

        ctx.fillStyle = '#ff0'; ctx.font = '12px Courier New';
        ctx.fillText("Current LEDs: " + currentLedLit, startX + 10, startY + 20);
        ctx.fillStyle = '#FFA500';
        ctx.fillText("Max LEDs:     " + maxLedLit, startX + 10, startY + 40);
        ctx.fillStyle = '#ccc';
        ctx.fillText("Min LEDs:     " + minLedLit, startX + 10, startY + 60);


        // --- TOOLTIP ---
        if (isHovering && mouseX >= 0 && mouseX < rawData.length) {
            let index = Math.floor(mouseX);
            let rVal = rawData[index];
            let aVal = ampData[index];
            let lVal = ledData[index];
            let pVal = peakData[index];
            let histMax = maxData[index];
            let histBias = biasData[index];

            if(rVal !== undefined) {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]); ctx.beginPath(); ctx.moveTo(mouseX, 0); ctx.lineTo(mouseX, rect.height); ctx.stroke(); ctx.setLineDash([]);
                tooltip.innerHTML = `
                        <div style="color:#888; border-bottom:1px solid #444; margin-bottom:4px;">
                            Bias: <b>${histBias}</b> | Max: <b style="color:#0ff">${histMax}</b>
                        </div>
                        <span style="color:#0f0">‚óè</span> Raw: <b style="color:#fff">${rVal}</b><br>
                        <span style="color:#f0f">‚óè</span> Sound: <b style="color:#fff">${aVal}</b><br>
                        <hr style="border-color:#333; margin:3px 0">
                        <span style="color:#FFA500">‚óè</span> LED Bar: <b>${lVal}</b><br>
                        <span style="color:#fff">‚óè</span> Peak: <b>${pVal}</b>
                    `;
            }
        }
        requestAnimationFrame(draw);
    }
    draw();

    function processData(text) {
        inputBuffer += text;
        let lines = inputBuffer.split('\n');
        inputBuffer = lines.pop();
        for (let line of lines) {
            let parts = line.trim().split(',');
            if (parts.length === 7) {
                let r = parseInt(parts[0]); let a = parseInt(parts[1]); let m = parseInt(parts[2]);
                let z = parseInt(parts[3]); let l = parseInt(parts[4]); let p = parseInt(parts[5]);
                let mode = parseInt(parts[6]);
                if (!isNaN(r)) {
                    rawData.push(r); rawData.shift(); ampData.push(a); ampData.shift();
                    ledData.push(l); ledData.shift(); peakData.push(p); peakData.shift();

                    if (!isNaN(m)) currentMax = m;
                    if (!isNaN(z)) currentBias = z;

                    maxData.push(currentMax); maxData.shift();
                    biasData.push(currentBias); biasData.shift();

                    currentLedLit = l;
                    if (l === 0) {
                        minLedLit = 0; maxLedLit = 0;
                    } else {
                        if (maxLedLit === 0) minLedLit = l;
                        if (l > maxLedLit) maxLedLit = l;
                        if (l < minLedLit) minLedLit = l;
                    }

                    const modeText = document.getElementById('modeText');
                    if (mode === 1) {
                        modeText.textContent = "üéµ MUSIC VISUALIZER";
                        modeText.style.color = "#0f0"; // Green
                        modeText.style.textShadow = "0 0 10px #0f0";
                    } else {
                        modeText.textContent = "‚ú® STATIC EFFECTS";
                        modeText.style.color = "#ffa500"; // Orange
                        modeText.style.textShadow = "0 0 10px #ffa500";
                    }
                }
            }
        }
    }

    resetBtn.addEventListener('click', () => {
        rawData.fill(512); ampData.fill(0); ledData.fill(0); peakData.fill(0);
        maxData.fill(100); biasData.fill(512);
        maxLedLit = 0; minLedLit = NUM_LEDS; currentLedLit = 0;
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; isHovering = true; tooltip.style.left = (e.pageX + 15) + 'px'; tooltip.style.top = (e.pageY + 15) + 'px'; tooltip.style.display = 'block';
    });
    canvas.addEventListener('mouseleave', () => { isHovering = false; tooltip.style.display = 'none'; });
    pauseBtn.addEventListener('click', () => { isPaused = !isPaused; pauseBtn.textContent = isPaused ? "‚ñ∂ RESUME" : "‚è∏ PAUSE"; pauseBtn.classList.toggle('active'); });

    connectBtn.addEventListener('click', async () => {
        if (!navigator.serial) return alert("Use Chrome/Edge");
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });

            statusDisplay.textContent = "Status: Connected!"; statusDisplay.style.color = "#0f0";
            connectBtn.style.display = 'none';
            disconnectBtn.style.display = 'inline-block';

            const textDecoder = new TextDecoderStream();
            readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
            reader = textDecoder.readable.getReader();

            while (true) { const { value, done } = await reader.read(); if (done) break; if (!isPaused) processData(value); }
        } catch (err) { console.error(err); resetUI(); }
    });

    disconnectBtn.addEventListener('click', async () => {
        try {
            if (reader) { await reader.cancel(); reader = null; }
            if (readableStreamClosed) await readableStreamClosed.catch(() => {});
            if (port) { await port.close(); port = null; }
        } catch (e) { console.error("Disconnect Cleanup Error:", e); port = null; }
        resetUI();
    });

    function resetUI() {
        connectBtn.style.display = 'inline-block';
        disconnectBtn.style.display = 'none';
        statusDisplay.textContent = "Status: Disconnected"; statusDisplay.style.color = "#fff";
    }
</script>
</body>
</html>